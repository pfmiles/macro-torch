# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

macro-torch is a World of Warcraft addon for Turtle WoW (private server) that generates SuperMacro addon code. It provides a macro creation helper with object-oriented Lua classes and combat event tracking.

## Build and Development Commands

### Build the addon

```bash
./build.sh
```

The build script concatenates all Lua files in a specific order into `SM_Extend.lua` and copies it to the SuperMacro addon directory.

**File Concatenation Order:**
1. `macro_torch.lua` - Global namespace initialization
2. `impl_util.lua` - Utility functions
3. `interface_debug.lua` - Debug interface functions
4. `Unit.lua` - Base Unit class
5. All other `*.lua` files (except the output file)

**Note:** Do not manually edit `SM_Extend.lua` - it is generated by the build script and ignored by git.

## Code Architecture

### Object-Oriented Design

The codebase uses Lua metatables to implement class inheritance. Key classes:

- **macroTorch.Unit** - Base class for all units (defined in `Unit.lua`)
  - Handles buff/debuff detection, tracking, and management
  - Provides methods for checking unit state

- **macroTorch.Player** - Player-specific functionality (extends Unit)
  - Defined in `Player.lua`
  - Spell casting, item usage, trinket management, form/stance checks

- **macroTorch.Target** - Target-specific functionality (extends Unit)
  - Defined in `Target.lua`
  - Immunity tracking, damage prediction, special target handling

- **Class-Specific Classes** - Inherit from Player
  - `macroTorch.Druid`, `macroTorch.Hunter`, etc. (in `SM_Extend_{Class}.lua`)
  - Class-specific rotation logic and abilities

### Global Objects

Three core global objects are available in all contexts:
- `macroTorch.player` - Current player instance
- `macroTorch.target` - Current target
- `macroTorch.pet` - Player's pet

### Metatable Structure

Classes use custom `__index` metamethods that search in this order:
1. Instance-specific field maps (e.g., `DRUID_FIELD_FUNC_MAP`)
2. Class methods/fields
3. Parent class methods/fields

### Combat State Management

The `battle_event_queue.lua` file implements:
- Event-driven combat tracking using WoW API events
- Spell trace registration and immune tracking
- Context management (stored in `macroTorch.context`)
- Dodge/parry/resist detection

## File Organization

- **Core Classes**: `Unit.lua`, `Player.lua`, `Target.lua`, `Pet.lua`
- **Class Logic**: `SM_Extend_{Class}.lua` (Druid, Hunter, Mage, etc.)
- **Utilities**: `impl_util.lua` (string/table utilities), `interface_debug.lua` (debugging)
- **Combat System**: `battle_event_queue.lua` (event handling, immunity tracking)
- **Supporting**: `TargetTarget.lua`, `TargetPet.lua`, `Group.lua`, `Raid.lua`

## Key Patterns

### Creating New Class Methods

```lua
-- In a class file (e.g., SM_Extend_Druid.lua)
function obj.methodName(params)
    -- Access global objects: macroTorch.player, macroTorch.target
    -- Use utility functions from impl_util.lua
    -- Check combat state via macroTorch.context
end
```

### Adding Field Function Maps

```lua
-- For class-specific dynamic fields, add to the appropriate map
macroTorch.DRUID_FIELD_FUNC_MAP["fieldName"] = function(target)
    -- Return computed value
end
```

### Working with Combat Context

```lua
-- Context is automatically managed during combat
if macroTorch.context then
    -- Store temporary state
    macroTorch.context.customField = value
end
```

## Important Notes

- The codebase is designed for WoW 1.12.1 (Vanilla/Turtle WoW) API
- Requires SuperMacro addon to function
- Combat events and timing are critical - maintain the existing timing constants
- Buff/debuff detection relies on texture strings, not names
- Always test changes in-game as Lua errors break WoW macros

## Business Logic & Domain Knowledge

### Core Design Philosophy

This addon simplifies macro creation by providing one-button combat rotations for all classes. The key principle is **intelligent resource management** - the code continuously evaluates combat state and makes optimal decisions automatically.

### Common Abbreviations

The codebase uses extensive abbreviations for combat mechanics:

| Abbreviation | Meaning | Context |
|-------------|---------|---------|
| ooc | Out of Combat (脱战) | Energy regeneration state, triggers special abilities |
| cp | Combo Points (连击点) | Used for finishing moves (Rogue/Druid) |
| ff | Faerie Fire (精灵之火) | Debuff, armor reduction |
| rip | Rip (撕扯) | Druid bleed DoT |
| rake | Rake (斜掠) | Druid bleed DoT |
| shred | Shred (撕碎) | Druid combo builder |
| claw | Claw (爪击) | Druid combo builder |
| bite | Ferocious Bite (凶猛撕咬) | Druid finishing move |
| fero | Feral/Bear form or Idol of Ferocity | Context-dependent |
| KS | Kill Shot/斩杀阶段 | Target's last 20% HP |
| erps | Energy Regeneration Per Second | Used for precise energy calculations |
| TF | Tiger's Fury (猛虎之怒) | Energy boost ability |
| relic/set idol | Relic slot item (神像) | Equipment-swapping mechanics |

### Key Combat Patterns

#### 1. Energy Overflow Prevention
The addon performs **precise energy overflow calculations** before major abilities:

```lua
-- Example: Check if energy will overflow during Rip cast
if player.mana + (erps * 2) - RIP_COST > 100 then
    -- Energy would overflow, discharge first
    regularAttack()
end
```

**Formula**: `current_energy + (regen_per_sec × time_window) - ability_cost > 100`

Common time windows:
- Rip: 2 seconds (1s GCD + 1s possible ooc)
- Relic swap: 2.5 seconds (1.5s swap + 1s possible ooc)

#### 2. Relic Dance (神像舞)
Critical mechanic where the addon swaps relics before important casts for damage optimization:

- **Idol of Savagery**: Boosts Rip damage
- **Idol of Ferocity**: Boosts Shred/Claw damage
- Swapping takes 1.5 seconds (no GCD but triggers cooldown)
- Must calculate if energy will overflow during swap

#### 3. Energy Discharge Logic (泄能)
When energy would cap, the addon uses "filler" abilities efficiently:

```lua
-- Priority order for energy discharge:
1. Regular attack (Shred/Claw based on position)
2. Rake (if not present)
3. Wait for Rip (if 5cp and Rip active)
```

#### 4. Kill Shot Priority
When targets are in execute range (<20% HP), logic changes:
- Prioritize finishing moves regardless of optimal rotation
- Use health thresholds: KS_CP1_Health = 750, KS_CP2_Health = 1000, etc.
- Override normal combo point optimization

#### 5. Trivial Battle Detection
For short fights or PvP, the rotation simplifies:
- Skip complex DoT management
- Use `isTrivialBattleOrPvp()` to detect
- Faster burst, less optimization

### Class-Specific Patterns

#### Druid (Cat Form)
**Core Rotation Principles**:
1. **Maintain DoTs**: Keep Rip (5cp) and Rake active
2. **Energy efficiency**: Never cap energy, use free GCDs
3. **Combo point management**:
   - 5cp: Bite (if Rip active)
   - <5cp: Build with Shred (behind) or Claw (front)
4. **ooc weaving**: Use energy-free attacks during ooc
5. **Relic optimization**: Swap to Savagery for Rip, Ferocity for builders

**Key Functions**:
- `regularAttack()`: Unified energy discharge + combo building (uses `shouldUseShred`), see Module Priority Order
- `keepRip()`: 5cp Rip maintenance with relic dance, uses `shouldCastRip`
- `quickKeepRip()`: Fast Rip for 1-2cp (quick battle mode), uses `shouldCastRip`
- `energyDischargeBeforeBite()`: Optimize energy before Ferocious Bite
- `catAtk()`: Main entry point, implements module priority system
- `shouldUseShred()`: Shared Shred/Claw decision logic
- `shouldCastRip()`: Shared Rip casting decision (handles battle modes)
- `shouldUseBite()`: Shared Bite casting decision (complex battle mode logic)
- `canDoReshift()`: Action-availability based reshift logic

**Energy Regeneration Mechanics (Ancient Brutality Talent)**:

The addon implements precise energy regeneration calculations based on the Ancient Brutality talent and snapshot mechanics:

| Talent Rank | Energy per Tick | Rake Tick | Rip Tick | Pounce Tick |
|-------------|-----------------|-----------|----------|-------------|
| 0 (No talent) | 0 | 3s | 2s | 3s |
| 1 (Partial) | 3 | 3s | 2s | 3s |
| 2 (Full) | 5 | 3s | 2s | 3s |

**Snapshot Mechanic**: Bleed effect durations and tick intervals are determined at cast time based on whether Idol of Savagery was equipped. This "snapshot" is stored in context:
- `macroTorch.context.lastRakeEquippedSavagery` - Rake cast equipment state
- `macroTorch.context.lastRipEquippedSavagery` - Rip cast equipment state

**Idol of Savagery Effect**: Reduces tick interval by 10% (multiplies interval by 0.9)
- Rake: 3s → 2.7s
- Rip: 2s → 1.8s
- Pounce: Not affected (always 3s)

**Calculation Methods**:
```lua
-- Energy per second = energyPerTick / tickInterval
clickContext.RAKE_ERPS = macroTorch.computeRake_Erps()  -- Considers talent + snapshot
clickContext.RIP_ERPS = macroTorch.computeRip_Erps()    -- Considers talent + snapshot
clickContext.POUNCE_ERPS = macroTorch.computePounce_Erps() -- Considers talent only
```

**Rip Duration Calculation**:
- Base duration: 10 seconds (`macroTorch.RIP_BASE_DURATION`)
- Per combo point: +2 seconds
- With Savagery idol: ×0.9 (10% reduction)
- Formula: `(BASE_DURATION + (CP-1)×2) × (lastRipEquippedSavagery and 0.9 or 1.0)`

**Cat Form Combat Logic Architecture**:

The `catAtk()` function implements a modular combat system with carefully ordered priority:

**Core Design Principles**:
1. **clickContext**: Single-click scope cache for optimizing value retrieval
2. **Relic Management**: Dynamically selects normal relic based on target immunity
   - Target immune to bleed: Idol of Ferocity
   - Otherwise: Idol of Savagery
3. **Ordered Module Execution**: Modules execute in specific priority order (not numerical order)

**Module Priority Order** (as implemented in code):
```
0. Idol Recover - Equip current normal relic if not equipped
1. Health & Mana Saver - Emergency healing/potions in combat
2. Target Enemy - Auto-switch target if current is invalid
3. Keep AutoAttack - Maintain auto-attack in combat
4. Rush Mod - Burst abilities (trinkets, berserk, potions via Shift key)
5. Opener Mod - Stealth opener selection (Pounce vs Ravage)
7. oocMod - Omen of Clarity energy-free spell logic
6. Term Mod - Finishing moves (Ferocious Bite)
8. OT Mod - Threat management (Cower, threat reduction)
9. Tiger Fury - Maintain Tiger's Fury buff
10. Debuff Mod - Rip, Rake, and Faerie Fire management
11. Regular Attack - Builder spells (Claw/Shred based on position/bleeds)
12. Reshift Mod - Energy reset via form shifting (turtle-wow specific)
```

**Important**: Module execution order is critical. Earlier modules handle higher priority actions, making later modules (especially Reshift) more likely to encounter "nothing to do" states. Reshift being last ensures all reasonable actions are considered before resetting energy.

### Combat Mode Distinctions

The codebase distinguishes between **Normal Battles** and **Quick Battles** (PvP, trivial fights) with different logic:

#### Normal Battle Logic
- **Rip**: 5 combo points for maximum bleed damage
- **Bite**: 5 combo points with Rip active (or target immune)
- **Rotation**: Full optimization with relic swaps and energy management

#### Quick Battle Logic (`isTrivialBattleOrPvp()` or `clickContext.rough`)
- **Rip**: 1-2 combo points for fast application (amplifies后续claw damage)
- **Bite**:
  - CP ≥ 3 when Rip NOT present AND target NOT immune (consume CP to reach 1-2 CP range)
  - CP5 with Rip present OR target immune
- **Rotation**: Reduced optimization, skips complex decisions

**Key Insight**: CP≥3 bite in quick battles specifically serves to quickly consume combo points and reach the 1-2 CP range where low-star Rip application is optimal.

### Helper Functions and Single Point of Truth

To maintain consistency, complex decision logic is extracted into shared helper functions:

```lua
-- Shred vs Claw decision (position, bleeds, ooc status)
function macroTorch.shouldUseShred(clickContext)
    -- Returns true if Shred should be used over Claw
end

-- Rip casting decision (handles normal vs quick battle CP requirements)
function macroTorch.shouldCastRip(clickContext)
    -- Returns true if Rip should be cast based on battle mode and CP
end

-- Bite casting decision (complex battle mode + immunity logic)
function macroTorch.shouldUseBite(clickContext)
    -- Returns true if Bite should be used, considering:
    -- - Kill Shot phase (any CP)
    -- - Quick battle without Rip (CP≥3, target not immune)
    -- - Normal battle (CP5 with Rip or target immune)
end
```

**Principle**: Any logic used in multiple places (especially in `getMinimumAffordableAbilityCost` and actual casting functions) must be extracted to a shared helper to ensure consistency.

### Rip Immunity Considerations

Always check `clickContext.isImmuneRip` when making Rip/Bite decisions:
- If target is **immune to Rip**: Skip Rip logic, fall back to bite at CP5
- If target is **not immune**: Apply normal/quick battle Rip logic
- This affects both `shouldCastRip()` and `shouldUseBite()` decisions

### Reshift Module Design

**Core Principle**: Reshift triggers based on **"nothing reasonable to do"** rather than **"energy profit"**.

```lua
-- New logic (action-availability based)
if (current_energy + gcd_recovery) < min_ability_cost then
    return true  -- Nothing to do, reshift
end

-- Old logic (profit-based, deprecated)
if energy_profit > threshold then
    return true  -- Energy gain is positive
end
```

**Reshift Preconditions** (DO NOT reshift if):
- Not in combat
- Prowling (stealthed)
- OOC (Omen of Clarity active)
- Kill Shot/Last Chance phase (execute window too critical)

**Minimum Ability Cost Calculation** (`getMinimumAffordableAbilityCost`):
Checks available actions in priority order:
1. Tiger's Fury (if not active)
2. Shred (based on position/bleed count)
3. Rake (if not present and target not immune)
4. Rip (if should cast based on battle mode)
5. Ferocious Bite (if should use based on complex conditions)
6. Default: Claw

This ensures reshift only triggers during genuine downtime, maximizing DPS by converting idle periods into energy.

**Strategic Decision Logic**:

1. **Opener Selection** (Pounce vs Ravage):
   - Ravage: Use when target health < 1500 (can one-shot)
   - Pounce: Use when target health ≥ 1500 (stun + damage amplification)

2. **Combat Duration Detection**:
   - **PvP or Short Fights** (`clickContext.rough` or `isTrivialBattleOrPvp()`):
     - Use low-combo-point Rip (3cp) for faster ramp-up
     - Rip has long return period, target won't survive full duration
   - **Normal/Long Fights**:
     - Use 5-combo-point Rip for maximum bleed damage

3. **Faerie Fire Spam Strategy**:
   - Extremely low cost: Only 1s GCD, no energy cost
   - Can trigger ooc (Omen of Clarity) like other attacks
   - Cast even if debuff present: "When there's nothing else to do"

4. **Module Order Rationale**:
   - oocMod (7) before termMod (6): ooc has higher priority than finishers
   - OT Mod (8) after termMod (6): Finisher handling more important than threat

**Future TODOs Identified**:
1. **Bear Form Separation**: Bear form logic should be extracted and routed at macro level based on current form
2. **Reshift Enchantment**: Energy restore calculation should consider wolfheart head enchant
3. **Mana Reading Fix**: Cat form reads energy instead of real mana, needs future implementation

### Implementation Best Practices

1. **Refactoring for Maintainability**
   - Consolidate duplicate logic (e.g., `doDischargeEnergy` → `regularAttack`)
   - Use consistent naming (camelCase, avoid abbreviations in public APIs)
   - Comment critical calculations and thresholds
   - **Extract shared decision logic**: Any logic used in multiple places (especially in `getMinimumAffordableAbilityCost` and actual casting functions) MUST be extracted to a shared helper (see `shouldUseShred`, `shouldCastRip`, `shouldUseBite`)
   - **Single Point of Truth**: Decision logic should exist in exactly one place

2. **Performance Considerations**
   - Minimize API calls in hot paths
   - Cache frequently accessed values (erps, thresholds) in `clickContext`
   - Use early returns to reduce nesting
   - Compute values lazily and cache in `clickContext` to avoid redundant calculations

3. **Combat State Consistency**
   - Always check `isInCombat` before combat actions
   - Validate target state (`isCanAttack`, classification)
   - Handle edge cases (immune, behind-check failures)
   - Check all preconditions before casting (energy, range, GCD, form, etc.)

4. **Battle Mode Awareness**
   - Always consider both normal and quick battle scenarios
   - Use `isTrivialBattleOrPvp()` or `clickContext.rough` to detect quick battles
   - Document different CP requirements and logic for each mode

5. **Testing Considerations**
   - Test both normal and quick battle modes
   - Test with and without Rip immunity
   - Test energy overflow scenarios at different ERPS values
   - Verify module execution order and side effects
